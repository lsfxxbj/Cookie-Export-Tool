# 开发指南

## 项目概述

Cookie Exporter 是一个 Chrome 扩展程序，用于导出、导入和管理浏览器 Cookie。该项目采用了模块化的设计理念，将功能拆分为多个独立的模块，以提高代码的可维护性和可扩展性。

## 技术栈

- JavaScript (ES6+)
- HTML5
- CSS3
- Chrome Extension APIs

## 项目结构

```
.
├── _locales/                 # 国际化资源文件
├── js/
│   ├── modules/             # 核心功能模块
│   │   ├── errors/          # 错误处理模块
│   │   ├── export/          # 导出相关模块
│   │   └── ...              # 其他功能模块
│   ├── ui/                  # UI 管理模块
│   └── utils/               # 工具函数模块
├── background.js            # 后台服务工作者
├── popup.js                 # 弹窗主脚本
├── popup.html               # 弹窗界面
├── popup.css                # 弹窗样式
├── manifest.json            # 扩展清单文件
└── docs/                   # 文档目录
```

## 模块化设计

项目采用模块化设计，每个功能都被封装在一个或多个模块中。这样做的好处包括：

1. **可维护性** - 每个模块都有明确的职责，易于理解和修改
2. **可复用性** - 模块可以在不同地方重复使用
3. **可测试性** - 每个模块都可以独立测试
4. **团队协作** - 不同开发者可以并行开发不同模块

### 核心模块依赖关系

以下是项目中各模块之间的依赖关系图：

```
popup.js
  ↓
popupInitializer.js
  ↓ ↘
cookieOperations.js  exportOperations.js  fileOperations.js  eventListeners/index.js
  ↓                    ↓                  ↓                  ↓
cookieCounter.js    export/*           importManager.js   eventListenerManager.js
  ↓                    ↓                  ↓                  ↓
filterManager.js    export/*           ui/uiManager.js    DOMManager.js
  ↓                    ↓                  ↓                  ↓
i18n/index.js       ui/uiManager.js   DOMManager.js       ...
  ↓                    ↓
DOMManager.js       i18n/index.js
  ↓
i18n/index.js
```

模块依赖遵循以下原则：
1. **避免循环依赖** - 模块之间不应形成循环依赖关系
2. **分层依赖** - 上层模块可以依赖下层模块，但不能反向依赖
3. **功能聚合** - 相关功能放在同一层级或相邻层级

### 核心模块

#### 错误处理模块

错误处理是任何应用程序的重要组成部分。我们在 `js/modules/errors/` 目录中实现了统一的错误处理机制：

- `ErrorHandler.js` - 核心错误处理逻辑
- `ErrorLogger.js` - 错误日志记录
- `ErrorDisplay.js` - 错误信息显示

所有错误都应该通过这些模块进行处理，而不是直接使用 console 或 alert。

#### 数据处理模块

数据处理模块负责处理 Cookie 的导入和导出：

- `export/` - 导出相关模块
- `importManager.js` - 导入相关功能

#### UI 模块

UI 模块负责处理用户界面相关的功能：

- `ui/uiManager.js` - UI 管理功能

#### 国际化模块

国际化模块负责处理所有本地化和国际化相关的功能：

- `i18n/i18nManager.js` - 国际化核心功能
- `localization/translations.js` - 翻译资源

国际化模块支持中文（zh-CN）、英文（en）和法文（fr）三种语言，会根据用户的浏览器语言自动选择默认语言。

## 编码规范

### 命名约定

1. **文件名** - 使用驼峰命名法，如 `errorHandler.js`
2. **函数名** - 使用驼峰命名法，如 `handleError`
3. **变量名** - 使用驼峰命名法，如 `errorMessage`
4. **常量名** - 使用全大写加下划线，如 `MAX_RETRY_COUNT`

### 参数命名规范

函数参数命名必须准确反映实际传入的变量含义，避免使用可能引起混淆的名称。例如，如果一个参数实际接收的是浏览文件按钮，应该命名为 `triggerButton` 或类似的描述性名称。

涉及按钮元素的函数参数应统一命名为 `button` 或 `triggerButton`，确保在整个项目中保持一致性和准确性。

### 注释规范

所有函数都需要有详细的 JSDoc 注释，包括：

```javascript
/**
 * 函数描述
 * @param {类型} 参数名 - 参数描述
 * @returns {类型} 返回值描述
 */
function functionName(param) {
  // 函数实现
}
```

### 错误处理

所有可能出错的地方都要进行错误处理：

```javascript
try {
  // 可能出错的代码
} catch (error) {
  ErrorHandler.handleError(error, '上下文信息');
}
```

## 国际化

项目支持多语言，通过 `_locales/` 目录下的语言包实现。使用 `chrome.i18n.getMessage()` 方法获取本地化字符串。

### 语言支持

项目支持以下三种语言：
1. 中文（zh-CN）
2. 英文（en）
3. 法文（fr）

### 自动语言检测

扩展会自动检测用户的浏览器语言设置，并根据以下优先级选择默认语言：
1. 如果浏览器语言在支持列表中，则使用该语言
2. 如果浏览器语言以 "zh" 开头，则使用中文
3. 其他情况默认使用英文

### 本地化实现

本地化通过以下方式实现：
1. 使用 `data-i18n` 属性标记需要本地化的元素
2. 使用 `data-i18n-placeholder` 属性标记需要本地化占位符的输入元素
3. 使用 `data-i18n-aria-label` 属性标记需要本地化 aria-label 的元素
4. 通过 `I18n.applyLocalization()` 方法应用本地化

### 添加新语言

要添加新语言支持，需要执行以下步骤：
1. 在 `_locales/` 目录下创建对应语言的子目录
2. 在该目录下创建 `messages.json` 文件，包含所有翻译键值对
3. 在 `js/modules/localization/translations.js` 中添加该语言的翻译映射
4. 在语言选择器中添加对应的语言选项

## 测试

目前项目没有自动化测试，但我们计划在未来添加单元测试和集成测试。

建议采用以下测试框架：

1. **单元测试** - Jest 或 Mocha
2. **集成测试** - Puppeteer 或 Selenium

测试应该覆盖以下方面：

1. **核心功能** - Cookie 导入/导出功能
2. **错误处理** - 各种异常情况的处理
3. **UI 交互** - 用户界面的各种操作
4. **数据验证** - 输入数据的验证逻辑
5. **国际化** - 不同语言环境下的表现

## 构建和部署

### 开发环境搭建

1. 克隆项目仓库
2. 在 Chrome 浏览器中打开 `chrome://extensions/`
3. 开启"开发者模式"
4. 点击"加载已解压的扩展程序"
5. 选择项目根目录

### 生产环境部署

1. 确保所有功能测试通过
2. 更新版本号在 `manifest.json` 中
3. 打包扩展程序
4. 提交到 Chrome Web Store

## 性能优化

### UI优化

1. **防止UI跳动** - 通过预设固定高度和宽度防止元素尺寸变化引起的跳动
2. **动画效果** - 使用CSS动画提供流畅的用户反馈
3. **进度条** - 在长时间操作中显示进度条提升用户体验

### 代码优化

1. **避免重复DOM查询** - 缓存常用的DOM元素引用
2. **防重复点击** - 在异步操作期间阻止重复点击
3. **模块化设计** - 将功能分解为小模块，提高可维护性

## 最佳实践

### 模块设计

1. **单一职责原则** - 每个模块应该只有一个改变的理由
2. **开放封闭原则** - 模块对扩展开放，对修改封闭
3. **依赖倒置原则** - 依赖于抽象而不是具体实现

### 错误处理

1. **统一错误处理** - 使用统一的错误处理模块
2. **错误日志记录** - 记录详细的错误信息用于调试
3. **用户友好提示** - 向用户提供清晰易懂的错误信息

### 国际化

1. **字符串外部化** - 所有用户可见的字符串都应外部化
2. **参数化消息** - 使用参数化消息支持动态内容
3. **语言一致性** - 确保所有语言版本的内容一致性